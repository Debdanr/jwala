apply plugin: "sonar-runner"

//test
ext {
    versions = [
            junit : "4.+",
            pmd : "4.3",
            spring : "3.2.6.RELEASE",
            spring_integration : "3.0.1.RELEASE",
            jackson : "1.4.2",
            jpa : "2.2.2",
            h2 : "1.3.175",
            cxf: "3.0.0-milestone1",
            javax_ws_rs_api: "2.0",
            mockito: "1.9.5",
            log4j : '1.2.17',
            slf4j : '1.7.5',
            slf4j_log4j12 : '1.7.5',
            javax_servlet_api: '3.0',
            csa : "2.3",
            commons_fileupload: '1.3.1',
            jodaTime : "2.2",
            jms : "1.1",
            infrastructureProvided : "1.0-SNAPSHOT",
            infrastructureSecurity : "1.0-SNAPSHOT",
            infrastructureGradle : "1.1.2-SNAPSHOT",
            commons_lang : "3.3.2",
            commons_logging : "1.1.1",
            httpcomponents_core : "4.3.3",
            httpcomponents_client : "4.3.3",
            tomcat : '7.0.55',
            ant: '1.8.2',
            groovy: '2.4.3',
            jacoco: '0.6.5.201403032054',
            devbundle: '1.1-SNAPSHOT'
    ]
}

sonarRunner {
    sonarProperties {
        property 'sonar.host.url', 'http://usmlvv1cto923.usmlvv1d0a.smshsc.net:9000'
        property 'sonar.jdbc.url', 'jdbc:mysql://usmlvv1cto923.usmlvv1d0a.smshsc.net/sonar'
        property 'sonar.jdbc.driverClassName', 'com.mysql.jdbc.Driver'
        property 'sonar.jdbc.username', 'sonar'
        property 'sonar.jdbc.password', 'sonar'
        property 'sonar.dynamicAnalysis', 'reuseReports'
        properties ["sonar.projectKey"] = 'cto.tco.toc'
        properties ["sonar.projectName"] = 'tomcat operations center'
        properties ["sonar.projectVersion"] = '1.0.0'
    }
}

task(clean) << {
    delete "build/jacoco"
}

subprojects {
    apply plugin: "java"
    apply plugin: "jacoco"
    apply plugin: "pmd"
    apply plugin: "eclipse"

    sourceCompatibility = 1.7
    group = "com.cerner.cto.aem"
    version = project.properties['buildVersion']

    plugins.withType(MavenPublishPlugin).whenPluginAdded {

        publishing {
            repositories {
                maven {
                    url project.properties['publishRepoUrl']
                    credentials {
                        username project.properties['publishRepoUser']
                        password project.properties['publishRepoPassword']
                    }
                }
            }
            publications {
                mavenJava(MavenPublication) {
                    if(project.name.equals('toc-webapp')) {
                        from components.web
                    } else {
                        from components.java
                    }
                    if(project.name.equals('toc-persistence')) {
                        artifact("drop.sql") {
                            classifier "drop"
                            extension "sql"
                        }
                        artifact("create.sql") {
                            classifier "create"
                            extension "sql"
                        }
                    }
                }
            }
        }
    }

    repositories {
        // TODO should we be pulling from the 464 artifactory?
        maven { url "http://usmlvv1srn464.usmlvv1d0a.smshsc.net/artifactory/repo/" }

        // jgroups
        // TODO is there a way to reference the virtual repo without naming it explicitly?
        // it works using https://artifactory/artifactory/repo/ and then org/jgroups/jgroups/3.6.6.Final/ in a browser but requires authentication from the build.gradle - which fails
        maven { url "http://usmlvv1qmp645.usmlvv1d0a.smshsc.net:8081/artifactory/jcenter-cache/"}
    }

    dependencies {

        compile group: 'org.slf4j', name: 'slf4j-api', version: "$versions.slf4j"
//        compile group: 'org.slf4j', name: 'slf4j-log4j12', version: "$versions.slf4j_log4j12"
        compile group: 'org.apache.commons', name: 'commons-lang3', version: "$versions.commons_lang"

        testCompile "junit:junit:4.11"
        testCompile group: 'org.mockito', name: 'mockito-core', version: "$versions.mockito"

        pmd group: "pmd", name: "pmd", version: "$versions.pmd"
    }

    jar {
        manifest {
            attributes(
                    "Implementation-Title": project.name,
                    "Implementation-Version": project.version + (null ==System.getProperty("BUILD_NUMBER") ? "" : "." + System.getProperty("BUILD_NUMBER")) + (null == System.getProperty("ACCUREV_TRANSACTION") ? "" : "." + System.getProperty("ACCUREV_TRANSACTION")),
                    "Built-By": System.getProperty("user.name"),
                    "Built-JDK": System.getProperty("java.version"),
                    "Built-Host": InetAddress.getLocalHost(),
                    "Build-Time-ISO-8601": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
            )
        }
    }

    pmdMain {
        reports {
            xml.enabled = true
            html.enabled = false
        }
    }

    pmdTest {
        reports {
            xml.enabled = true
            html.enabled = false
        }
    }

    jacoco {
        toolVersion = "$project.versions.jacoco"
    }

    jacocoTestReport {
        reports {
            xml.enabled = false
            csv.enabled = false
            html.enabled = true
            html.destination "${buildDir}/jacocoHtml"
        }
    }

    test {
        systemProperties['run.test.types'] = 'integration'
        systemProperties['spring.profiles.active'] = 'integration'
    }

    task copyResult(type: Copy) {
        from file("${project.buildDir.path}/jacoco/")
        into file("${project.rootProject.buildDir.path}/jacoco/")
        include "accum-${project.name}.exec"
        rename  "accum-${project.name}.exec", "accum.exec"
    }

    task mergeTestCodeCoverageResults(type: JacocoMerge) {
        description = 'Merge test code coverage results from all java projects'
        destinationFile = file("${project.buildDir.path}/jacoco/accum-${project.name}.exec")
        def mergeFile = file("${project.rootProject.buildDir.path}/jacoco/accum.exec")
        def testFile = file("${project.buildDir.path}/jacoco/test.exec")
        onlyIf {
            testFile.exists()
        }
        executionData {
            if(mergeFile.exists()) return files(mergeFile, testFile);
            else return files(testFile);
        }
        doLast {
            copyResult.execute();
        }
    }

    test.finalizedBy mergeTestCodeCoverageResults

    sonarRunner {
        sonarProperties {
            property "sonar.junit.reportsPath", test.reports.junitXml.destination   // will be fixed in Gradle 1.12
            property "sonar.jacoco.reportPath", project.rootProject.buildDir.path + "/jacoco/" + "accum.exec"
        }
    }
}
