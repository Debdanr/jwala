<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:int="http://www.springframework.org/schema/integration"
       xmlns:task="http://www.springframework.org/schema/task"
       xmlns:int-http="http://www.springframework.org/schema/integration/http"
       xsi:schemaLocation="http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration-3.0.xsd
                           http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd
                           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/integration/http http://www.springframework.org/schema/integration/http/spring-integration-http.xsd">

    <bean id="webServerProvider" class="com.siemens.cto.aem.service.webserver.heartbeat.WebServerServiceFacade">
        <constructor-arg ref="webServerService"/>
    </bean>

    <bean id="webServerStateServiceFacade" class="com.siemens.cto.aem.service.webserver.heartbeat.WebServerStateServiceFacade">
        <constructor-arg ref="webServerStateService"/>
        <constructor-arg ref="webServerDao"/>
    </bean>

    <bean id="webServerSshCommandExpression" class="org.springframework.integration.config.ExpressionFactoryBean">
        <constructor-arg value="@webServerServiceExistence.getServiceExistenceCommandFor(payload)"/>
    </bean>

    <bean id="webServerSshHostExpression" class="org.springframework.integration.config.ExpressionFactoryBean">
        <constructor-arg value="payload.host"/>
    </bean>

<!-- not used  
    <int:channel id="webServerServiceExistenceRequest"/>
    <int:channel id="webServerStateRequestPreparation"/>
    <int:channel id="webServerStateRequests"/>
 --> 

    <int:channel id="unsplitWebServerStateRequests"/>
    <int:channel id="splitWebServerStateRequests">
        <int:dispatcher task-executor="webServerStateExecutor"/>
    </int:channel>
    <int:channel id="webServerStateRequest">
        <int:dispatcher task-executor="webServerStateExecutor"/>
    </int:channel>
    <int:channel id="failedWebServerStateRequest">
        <int:dispatcher task-executor="webServerStateExecutor"/>
    </int:channel>
    <int:channel id="successfulWebServerStateRequest"/>
    <int:channel id="completedWithoutMessageWebServerStateRequest"/>
    <int:channel id="completedWithMessageWebServerStateRequest"/>
    <int:channel id="webServerServiceExistenceResult"/>
    <int:channel id="webServerNoService"/>
    <int:channel id="webServerBadHost"/>
    <int:channel id="webServerHasServiceResult"/>
    
    <!-- Heartbeat polling will use daemon threads so must use a thread factory configured in Java -->  
    <bean  id="webServerStateExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
        <property name="corePoolSize" value="5" />
        <property name="maxPoolSize" value="5" />
        <property name="queueCapacity" value="200" />
        <property name="keepAliveSeconds" value="5" />
        <property name="rejectedExecutionHandler" ref="generalCallerRunsPolicy" />
        <property name="threadFactory" ref="pollingThreadFactory" />
    </bean>
        
    <int:inbound-channel-adapter id="webServerStateInitiator"
                                 ref="webServerProvider"
                                 method="getAllWebServers"
                                 channel="unsplitWebServerStateRequests" phase="1000" auto-startup="false">
        <int:poller fixed-delay="${ping.webServer.period.millis}" time-unit="MILLISECONDS"/>
    </int:inbound-channel-adapter>

    <int:chain id="webServerRequestSplitter" input-channel="unsplitWebServerStateRequests" output-channel="splitWebServerStateRequests">
        <int:splitter/>
        <int:header-enricher id="webServerIdHeaderEnricher">
            <int:header name="webServerId" expression="payload.id"/>
        </int:header-enricher>
        <int:header-enricher id="webServerHeaderEnricher">
            <int:header name="webServer" expression="payload"/>
        </int:header-enricher>
    </int:chain>

    <!-- splitWebServerStateRequests =>  webServerPreHttpOutboundChain => webServerHttpOutboundGateway -->
    <int:chain id="webServerPreHttpOutboundChain" input-channel="splitWebServerStateRequests" output-channel="webServerStateRequest">
        <int:header-enricher default-overwrite="true">
            <int:error-channel ref="failedWebServerStateRequest"/>
        </int:header-enricher>
        <int:transformer id="webServerStatusUriTransformer" expression="headers['webServer'].getStatusUri().toString()"/>
    </int:chain>

    <int-http:outbound-gateway id="webServerHttpOutboundGateway"
                               request-channel="webServerStateRequest"
                               reply-channel="successfulWebServerStateRequest"
                               request-factory="webServerHttpRequestFactory"
                               http-method="GET" 
                               url-expression="payload"/>

    <!--  success splitWebServerStateRequests => successfulWebServerStateRequest  (end) -->
    <!--  failure splitWebServerStateRequests => failedWebServerStateRequest --> 
    <!--  end splitWebServerStateRequests  -->
    
    <!-- failedWebServerStateRequest => checkWebServerExistenceChain -->
    <int:chain id="checkWebServerExistenceChain" input-channel="failedWebServerStateRequest" output-channel="webServerServiceExistenceResult">
        <!-- acquire original payload, save failure message  -->
        <int:header-enricher>
            <int:header name="failureMessage"
               expression="@exceptionUtilHelper.getPenultimateRootCause(payload).getMessage()" />
            <int:header name="webServer" expression="payload.getFailedMessage().headers['webServer']"/>
            <int:header name="webServerId" expression="payload.getFailedMessage().headers['webServerId']"/>
        </int:header-enricher>

        <!-- acquire original Message payload --> 
        <int:transformer id="failedWebServerHttpTransformer" expression="payload.getFailedMessage().headers['webServer']"/>
        
        <int:header-enricher>
            <int:error-channel overwrite="true" value="webServerBadHost"/>
        </int:header-enricher>
        
        <int:service-activator method="handleSshMessage">
            <bean id="webServerSshHandler" class="com.siemens.cto.aem.si.ssh.SshExecExecutingService" autowire="constructor">
                <constructor-arg ref="webServerSshCommandExpression"/>
                <constructor-arg ref="webServerSshHostExpression"/>
            </bean>
        </int:service-activator>
    </int:chain>

    <int:router id="webServerServiceExistenceResultRouter" input-channel="webServerServiceExistenceResult" expression="payload.getReturnCode().wasSuccessful()">
        <int:mapping value="true" channel="webServerHasServiceResult"/>
        <int:mapping value="false" channel="webServerNoService"/>
    </int:router>
    <!--  success => successfulWebServerHttpChain (end) --> 
    <!--  failure => webServerBadHost, webServerNoService -->

    <!-- fail with original message -->
    <int:chain id="failedWebServerHttpChain" input-channel="webServerHasServiceResult" output-channel="completedWithoutMessageWebServerStateRequest">
        <int:header-enricher id="failedWebServerHttpHeaderEnricher">
            <int:header name="reachableState" value="#{T(com.siemens.cto.aem.domain.model.webserver.WebServerReachableState).WS_UNREACHABLE}"/>
        </int:header-enricher>
        <int:transformer id="successfulWebServerHttpTransformer" expression="headers['webServerId']"/>
    </int:chain>

    <int:chain id="successfulWebServerHttpChain" input-channel="successfulWebServerStateRequest" output-channel="completedWithoutMessageWebServerStateRequest">
        <int:header-enricher id="successfulWebServerHttpHeaderEnricher">
            <int:header name="reachableState" value="#{T(com.siemens.cto.aem.domain.model.webserver.WebServerReachableState).WS_REACHABLE}"/>
        </int:header-enricher>
        <int:transformer id="successfulWebServerHttpTransformer" expression="headers['webServerId']"/>
    </int:chain>

    <int:chain id="webServerBadHostChain" input-channel="webServerBadHost" output-channel="completedWithMessageWebServerStateRequest">
        <int:header-enricher id="webServerBadHostHeaderEnricher">
            <int:header name="webServerId" expression="payload.getFailedMessage().headers['webServerId']"/>
            <int:header name="reachableState" value="#{T(com.siemens.cto.aem.domain.model.webserver.WebServerReachableState).WS_FAILED}"/>
            <int:header name="failureMessage" expression="@exceptionUtilHelper.getPenultimateRootCause(payload).getMessage()"/>
            <int:header name="failureException" expression="payload"/>
        </int:header-enricher>
        <int:transformer id="webServerNoServiceTransformer" expression="headers['webServerId']"/>
    </int:chain>

    <int:chain id="webServerNoServiceChain" input-channel="webServerNoService" output-channel="completedWithMessageWebServerStateRequest">
        <int:header-enricher id="webServerNoServiceHeaderEnricher">
            <int:header name="reachableState" value="#{T(com.siemens.cto.aem.domain.model.webserver.WebServerReachableState).WS_FAILED}"/>
            <int:header name="failureMessage" expression="payload.standardErrorOrStandardOut()"/>
        </int:header-enricher>
        <int:transformer id="webServerNoServiceTransformer" expression="headers['webServerId']"/>
    </int:chain>

    <int:chain id="completedSuccessWebServerStateRequestChain" input-channel="completedWithoutMessageWebServerStateRequest" output-channel="nullChannel">
        <int:transformer id="completedWebServerStateRequestOutboundAdapter" expression="@webServerStateServiceFacade.setState(payload, headers['reachableState'], {T(org.joda.time.DateTime).now()})"/>
    </int:chain>

    <int:chain id="completedFailureWebServerStateRequestChain" input-channel="completedWithMessageWebServerStateRequest">
        <int:transformer id="completedWebServerStateRequestOutboundAdapter" expression="@webServerStateServiceFacade.setStateWithMessageAndException(payload, headers['reachableState'], {T(org.joda.time.DateTime).now()}, headers['failureMessage'], headers['failureException'])"/>
        <int:outbound-channel-adapter
            id="groupFsmOutboundAdapter"
            expression="@stateNotification.webServerStateChanged(payload)" />
    </int:chain>

    <int:gateway id="explicitWebServerStateGateway" service-interface="com.siemens.cto.aem.service.webserver.WebServerStateGateway">
        <int:method name="setExplicitState" request-channel="completedWithoutMessageWebServerStateRequest"/>
        <int:method name="initiateWebServerStateRequest" request-channel="unsplitWebServerStateRequests"/>
    </int:gateway>

</beans>